<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>éŠ€æ²³ç³»æ¢ç´¢ã‚¢ãƒ—ãƒª</title>
		<style>
			@import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap");

			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: "Orbitron", monospace;
				background: #000;
				color: #fff;
				overflow: hidden;
				cursor: crosshair;
			}

			#container {
				position: relative;
				width: 100vw;
				height: 100vh;
			}

			#info {
				position: absolute;
				top: 20px;
				left: 20px;
				z-index: 100;
				background: rgba(0, 20, 40, 0.8);
				padding: 15px;
				border-radius: 10px;
				border: 1px solid #00ffff;
				box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
				backdrop-filter: blur(5px);
			}

			#info h1 {
				color: #00ffff;
				font-size: 18px;
				margin-bottom: 10px;
				text-shadow: 0 0 10px #00ffff;
			}

			#info p {
				font-size: 12px;
				color: #ccc;
				line-height: 1.4;
			}

			#controls {
				position: absolute;
				top: 20px;
				right: 20px;
				z-index: 100;
				background: rgba(0, 20, 40, 0.8);
				padding: 15px;
				border-radius: 10px;
				border: 1px solid #00ffff;
				backdrop-filter: blur(5px);
			}

			#controls h3 {
				color: #00ffff;
				font-size: 14px;
				margin-bottom: 10px;
			}

			#controls p {
				font-size: 11px;
				color: #ccc;
				margin-bottom: 5px;
			}

			#modal {
				display: none;
				position: fixed;
				z-index: 1000;
				left: 0;
				top: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.8);
				backdrop-filter: blur(5px);
			}

			.modal-content {
				background: linear-gradient(135deg, #001122 0%, #003366 100%);
				margin: 5% auto;
				padding: 30px;
				border: 2px solid #00ffff;
				border-radius: 15px;
				width: 90%;
				max-width: 800px;
				position: relative;
				box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
				animation: modalSlideIn 0.3s ease-out;
			}

			@keyframes modalSlideIn {
				from {
					opacity: 0;
					transform: translateY(-50px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			.close {
				color: #00ffff;
				float: right;
				font-size: 28px;
				font-weight: bold;
				cursor: pointer;
				transition: all 0.3s;
			}

			.close:hover {
				color: #ffffff;
				text-shadow: 0 0 10px #00ffff;
			}

			.modal-header h2 {
				color: #00ffff;
				font-size: 24px;
				margin-bottom: 20px;
				text-shadow: 0 0 15px #00ffff;
			}

			.modal-body {
				color: #ccc;
				line-height: 1.6;
				display: flex;
				gap: 20px;
				align-items: flex-start;
			}

			.modal-text {
				flex: 1;
			}

			.modal-visual {
				flex: 0 0 250px;
				display: flex;
				flex-direction: column;
				gap: 10px;
			}

			.modal-image {
				width: 100%;
				height: 120px;
				border: 2px solid #00ffff;
				border-radius: 8px;
				background: #000011;
				overflow: hidden;
			}

			.modal-image img {
				width: 100%;
				height: 100%;
				object-fit: cover;
				border-radius: 6px;
				transition: transform 0.3s ease;
				display: block;
			}

			.modal-image img:hover {
				transform: scale(1.02);
			}

			.modal-3d {
				width: 100%;
				height: 120px;
				border: 2px solid #00ffff;
				border-radius: 8px;
				background: #000011;
				position: relative;
				overflow: hidden;
			}

			.modal-3d canvas {
				border-radius: 6px;
			}

			.celestial-label {
				position: absolute;
				bottom: 10px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.8);
				color: #00ffff;
				padding: 4px 8px;
				border-radius: 4px;
				font-size: 10px;
				border: 1px solid #00ffff;
				backdrop-filter: blur(3px);
				z-index: 300;
				display: none;
			}

			/* ãƒ¢ãƒã‚¤ãƒ«ç”¨ã®å¤©ä½“åè¡¨ç¤º */
			.mobile-planet-info {
				position: fixed;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background: rgba(0, 20, 40, 0.95);
				color: #00ffff;
				padding: 15px 20px;
				border-radius: 10px;
				border: 2px solid #00ffff;
				font-size: 16px;
				font-weight: bold;
				z-index: 1001;
				display: none;
				text-align: center;
				backdrop-filter: blur(10px);
				box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
			}

			.celestial-image {
				width: 100% !important;
				height: 100% !important;
				object-fit: cover;
				border-radius: 8px;
				position: relative;
				animation: planetRotate 20s linear infinite;
				transform-origin: center center;
				filter: brightness(1.1) contrast(1.1) saturate(1.2);
				transition: all 0.3s ease;
			}

			.celestial-image:hover {
				transform: scale(1.05);
				filter: brightness(1.3) contrast(1.2) saturate(1.4);
			}

			@keyframes planetRotate {
				0% {
					transform: rotate(0deg) scale(1);
				}
				25% {
					transform: rotate(90deg) scale(1.02);
				}
				50% {
					transform: rotate(180deg) scale(1);
				}
				75% {
					transform: rotate(270deg) scale(1.02);
				}
				100% {
					transform: rotate(360deg) scale(1);
				}
			}

			.sun-image {
				animation: sunPulse 3s ease-in-out infinite alternate !important;
			}

			@keyframes sunPulse {
				0% {
					transform: rotate(0deg) scale(1);
					filter: brightness(1.2) contrast(1.1) saturate(1.3)
						drop-shadow(0 0 20px #ffff00);
				}
				100% {
					transform: rotate(360deg) scale(1.05);
					filter: brightness(1.5) contrast(1.3) saturate(1.5)
						drop-shadow(0 0 30px #ffaa00);
				}
			}

			.earth-image {
				animation: earthRotate 15s linear infinite,
					earthGlow 4s ease-in-out infinite alternate !important;
			}

			@keyframes earthRotate {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}

			@keyframes earthGlow {
				0% {
					filter: brightness(1.1) contrast(1.1) saturate(1.3)
						drop-shadow(0 0 15px #4a90e2);
				}
				100% {
					filter: brightness(1.3) contrast(1.2) saturate(1.4)
						drop-shadow(0 0 25px #6bb6ff);
				}
			}

			.saturn-image {
				animation: saturnWobble 8s ease-in-out infinite !important;
			}

			@keyframes saturnWobble {
				0%,
				100% {
					transform: rotate(0deg) scale(1);
					filter: brightness(1.1) contrast(1.1) saturate(1.2);
				}
				25% {
					transform: rotate(5deg) scale(1.02);
					filter: brightness(1.2) contrast(1.15) saturate(1.3);
				}
				50% {
					transform: rotate(0deg) scale(1.01);
					filter: brightness(1.15) contrast(1.12) saturate(1.25);
				}
				75% {
					transform: rotate(-5deg) scale(1.02);
					filter: brightness(1.2) contrast(1.15) saturate(1.3);
				}
			}

			.gas-giant {
				animation: gasGiantSwirl 12s ease-in-out infinite !important;
			}

			@keyframes gasGiantSwirl {
				0% {
					transform: rotate(0deg) scale(1);
					filter: brightness(1.1) contrast(1.1) saturate(1.2) hue-rotate(0deg);
				}
				33% {
					transform: rotate(120deg) scale(1.03);
					filter: brightness(1.25) contrast(1.2) saturate(1.4) hue-rotate(10deg);
				}
				66% {
					transform: rotate(240deg) scale(1.01);
					filter: brightness(1.15) contrast(1.15) saturate(1.3)
						hue-rotate(-10deg);
				}
				100% {
					transform: rotate(360deg) scale(1);
					filter: brightness(1.1) contrast(1.1) saturate(1.2) hue-rotate(0deg);
				}
			}

			.rocky-planet {
				animation: rockyPlanetRotate 10s linear infinite,
					rockyGlow 6s ease-in-out infinite alternate !important;
			}

			@keyframes rockyPlanetRotate {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}

			@keyframes rockyGlow {
				0% {
					filter: brightness(1) contrast(1.1) saturate(1.1);
				}
				100% {
					filter: brightness(1.2) contrast(1.2) saturate(1.3);
				}
			}

			.moon-image {
				animation: moonPhases 8s ease-in-out infinite !important;
			}

			@keyframes moonPhases {
				0%,
				100% {
					transform: rotate(0deg) scale(1);
					filter: brightness(1) contrast(1.1) saturate(0.9);
				}
				25% {
					transform: rotate(90deg) scale(1.02);
					filter: brightness(1.1) contrast(1.15) saturate(1);
				}
				50% {
					transform: rotate(180deg) scale(1.01);
					filter: brightness(1.2) contrast(1.2) saturate(1.1);
				}
				75% {
					transform: rotate(270deg) scale(1.02);
					filter: brightness(1.1) contrast(1.15) saturate(1);
				}
			}

			.modal-body h3 {
				color: #00aaff;
				margin: 20px 0 10px 0;
				font-size: 18px;
			}

			.fact-list {
				list-style: none;
				padding-left: 0;
			}

			.fact-list li {
				background: rgba(0, 255, 255, 0.1);
				margin: 8px 0;
				padding: 10px;
				border-left: 3px solid #00ffff;
				border-radius: 5px;
			}

			#loading {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				z-index: 999;
				text-align: center;
			}

			.loading-spinner {
				width: 50px;
				height: 50px;
				border: 3px solid rgba(0, 255, 255, 0.3);
				border-top: 3px solid #00ffff;
				border-radius: 50%;
				animation: spin 1s linear infinite;
				margin: 0 auto 20px;
			}

			@keyframes spin {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}

			#object-label {
				position: absolute;
				background: rgba(0, 0, 0, 0.8);
				color: #00ffff;
				padding: 8px 12px;
				border-radius: 5px;
				font-size: 12px;
				pointer-events: none;
				border: 1px solid #00ffff;
				display: none;
				z-index: 200;
				backdrop-filter: blur(3px);
			}

			@media (max-width: 768px) {
				#info,
				#controls {
					display: none;
				}

				.modal-content {
					margin: 10% auto;
					width: 95%;
					padding: 20px;
				}
			}
		</style>
	</head>
	<body>
		<div id="loading">
			<div class="loading-spinner"></div>
			<p style="color: #00ffff">éŠ€æ²³ç³»ã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
		</div>

		<div id="container"></div>

		<div id="info">
			<h1>ğŸŒŒ éŠ€æ²³ç³»æ¢ç´¢ã‚¢ãƒ—ãƒª</h1>
			<p>ãƒã‚¦ã‚¹ã§å®‡å®™ã‚’æ¢ç´¢ã—ã€<br />å¤©ä½“ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è©³ç´°ã‚’ç¢ºèªã—ã‚ˆã†ï¼</p>
		</div>

		<div id="controls">
			<h3>æ“ä½œæ–¹æ³•</h3>
			<p>ğŸ–±ï¸ ãƒ‰ãƒ©ãƒƒã‚°: å›è»¢</p>
			<p>ğŸ¯ ãƒ›ã‚¤ãƒ¼ãƒ«: ã‚ºãƒ¼ãƒ </p>
			<p>ğŸ‘† ã‚¯ãƒªãƒƒã‚¯: å¤©ä½“è©³ç´°</p>
		</div>

		<div id="object-label"></div>
		<div id="mobile-planet-info" class="mobile-planet-info"></div>

		<div id="modal">
			<div class="modal-content">
				<span class="close">&times;</span>
				<div class="modal-header">
					<h2 id="modal-title">å¤©ä½“å</h2>
				</div>
				<div class="modal-body">
					<div class="modal-text">
						<div id="modal-content"></div>
					</div>
					<div class="modal-visual">
						<div class="modal-image">
							<img id="celestial-image" style="display: none" alt="å¤©ä½“ç”»åƒ" />
						</div>
						<div class="modal-3d" id="modal-3d-container"></div>
					</div>
				</div>
			</div>
		</div>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
		<script>
			function createProceduralTexture(bodyData) {
				const canvas = document.createElement("canvas");
				const ctx = canvas.getContext("2d");
				canvas.width = 512;
				canvas.height = 256;

				switch (bodyData.name) {
					case "å¤ªé™½":
						return createSunTexture(ctx, canvas);
					case "åœ°çƒ":
						return createEarthTexture(ctx, canvas);
					case "æœˆ":
						return createMoonTexture(ctx, canvas);
					case "ç«æ˜Ÿ":
						return createMarsTexture(ctx, canvas);
					case "æœ¨æ˜Ÿ":
						return createJupiterTexture(ctx, canvas);
					case "åœŸæ˜Ÿ":
						return createSaturnTexture(ctx, canvas);
					case "å¤©ç‹æ˜Ÿ":
						return createUranusTexture(ctx, canvas);
					case "æµ·ç‹æ˜Ÿ":
						return createNeptuneTexture(ctx, canvas);
					case "é‡‘æ˜Ÿ":
						return createVenusTexture(ctx, canvas);
					case "æ°´æ˜Ÿ":
						return createMercuryTexture(ctx, canvas);
					default:
						return createDefaultTexture(ctx, canvas, bodyData.color);
				}
			}

			function createSunTexture(ctx, canvas) {
				// å¤ªé™½ã®æ ¸èåˆæ¨¡æ§˜
				const gradient = ctx.createRadialGradient(256, 128, 0, 256, 128, 200);
				gradient.addColorStop(0, "#ffff66");
				gradient.addColorStop(0.3, "#ffaa00");
				gradient.addColorStop(0.6, "#ff6600");
				gradient.addColorStop(1, "#cc3300");

				ctx.fillStyle = gradient;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// å¤ªé™½ãƒ•ãƒ¬ã‚¢æ¨¡æ§˜
				for (let i = 0; i < 50; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;
					const radius = Math.random() * 20 + 5;

					const flareGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
					flareGradient.addColorStop(0, "rgba(255, 255, 255, 0.8)");
					flareGradient.addColorStop(1, "rgba(255, 255, 255, 0)");

					ctx.fillStyle = flareGradient;
					ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createEarthTexture(ctx, canvas) {
				// åœ°çƒã®æµ·ã¨é™¸
				const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
				gradient.addColorStop(0, "#87ceeb"); // åŒ—æ¥µã®æ°·
				gradient.addColorStop(0.2, "#4682b4"); // æµ·
				gradient.addColorStop(0.4, "#228b22"); // æ£®æ—
				gradient.addColorStop(0.6, "#daa520"); // ç ‚æ¼ 
				gradient.addColorStop(0.8, "#4682b4"); // æµ·
				gradient.addColorStop(1, "#e0e0e0"); // å—æ¥µã®æ°·

				ctx.fillStyle = gradient;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// å¤§é™¸æ¨¡æ§˜
				for (let i = 0; i < 15; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;
					const width = Math.random() * 100 + 50;
					const height = Math.random() * 50 + 20;

					ctx.fillStyle = `rgba(34, 139, 34, ${Math.random() * 0.5 + 0.3})`;
					ctx.fillRect(x, y, width, height);
				}

				// é›²æ¨¡æ§˜
				for (let i = 0; i < 30; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;
					const radius = Math.random() * 30 + 10;

					ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.4 + 0.2})`;
					ctx.beginPath();
					ctx.arc(x, y, radius, 0, Math.PI * 2);
					ctx.fill();
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createMoonTexture(ctx, canvas) {
				// æœˆã®è¡¨é¢
				ctx.fillStyle = "#c0c0c0";
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼
				for (let i = 0; i < 40; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;
					const radius = Math.random() * 25 + 5;

					const craterGradient = ctx.createRadialGradient(
						x,
						y,
						0,
						x,
						y,
						radius
					);
					craterGradient.addColorStop(0, "#808080");
					craterGradient.addColorStop(0.7, "#a0a0a0");
					craterGradient.addColorStop(1, "#c0c0c0");

					ctx.fillStyle = craterGradient;
					ctx.beginPath();
					ctx.arc(x, y, radius, 0, Math.PI * 2);
					ctx.fill();

					// ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ç¸
					ctx.strokeStyle = "#606060";
					ctx.lineWidth = 1;
					ctx.stroke();
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createMarsTexture(ctx, canvas) {
				// ç«æ˜Ÿã®èµ¤ã„è¡¨é¢
				const gradient = ctx.createLinearGradient(
					0,
					0,
					canvas.width,
					canvas.height
				);
				gradient.addColorStop(0, "#cd853f");
				gradient.addColorStop(0.3, "#cd5c5c");
				gradient.addColorStop(0.6, "#a0522d");
				gradient.addColorStop(1, "#8b4513");

				ctx.fillStyle = gradient;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// ç«æ˜Ÿã®æ¸“è°·ã¨ä¸˜
				for (let i = 0; i < 20; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;
					const length = Math.random() * 100 + 50;

					ctx.strokeStyle = `rgba(139, 69, 19, ${Math.random() * 0.5 + 0.3})`;
					ctx.lineWidth = Math.random() * 3 + 1;
					ctx.beginPath();
					ctx.moveTo(x, y);
					ctx.lineTo(x + length, y + Math.random() * 20 - 10);
					ctx.stroke();
				}

				// æ¥µå† 
				ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
				ctx.fillRect(0, 0, canvas.width, 20);
				ctx.fillRect(0, canvas.height - 20, canvas.width, 20);

				return new THREE.CanvasTexture(canvas);
			}

			function createJupiterTexture(ctx, canvas) {
				// æœ¨æ˜Ÿã®ç¸æ¨¡æ§˜
				const stripes = [
					"#daa520",
					"#ff8c00",
					"#ffa500",
					"#ffb347",
					"#daa520",
					"#cd853f",
				];

				const stripeHeight = canvas.height / stripes.length;

				stripes.forEach((color, index) => {
					ctx.fillStyle = color;
					ctx.fillRect(0, index * stripeHeight, canvas.width, stripeHeight);
				});

				// å¤§èµ¤æ–‘
				const spotX = canvas.width * 0.7;
				const spotY = canvas.height * 0.4;
				const spotGradient = ctx.createRadialGradient(
					spotX,
					spotY,
					0,
					spotX,
					spotY,
					40
				);
				spotGradient.addColorStop(0, "#ff4500");
				spotGradient.addColorStop(0.5, "#ff6347");
				spotGradient.addColorStop(1, "rgba(255, 99, 71, 0)");

				ctx.fillStyle = spotGradient;
				ctx.beginPath();
				ctx.ellipse(spotX, spotY, 50, 30, 0, 0, Math.PI * 2);
				ctx.fill();

				// åµæ¨¡æ§˜
				for (let i = 0; i < 10; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;

					ctx.fillStyle = `rgba(255, 165, 0, ${Math.random() * 0.3 + 0.1})`;
					ctx.beginPath();
					ctx.ellipse(
						x,
						y,
						Math.random() * 20 + 10,
						Math.random() * 10 + 5,
						0,
						0,
						Math.PI * 2
					);
					ctx.fill();
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createSaturnTexture(ctx, canvas) {
				// åœŸæ˜Ÿã®æ·¡ã„è‰²åˆã„
				const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
				gradient.addColorStop(0, "#faf0e6");
				gradient.addColorStop(0.3, "#f5deb3");
				gradient.addColorStop(0.6, "#deb887");
				gradient.addColorStop(1, "#d2b48c");

				ctx.fillStyle = gradient;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// ç¸æ¨¡æ§˜
				for (let i = 0; i < 8; i++) {
					const y = (canvas.height / 8) * i;
					ctx.fillStyle = `rgba(210, 180, 140, ${Math.random() * 0.3 + 0.1})`;
					ctx.fillRect(0, y, canvas.width, canvas.height / 16);
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createUranusTexture(ctx, canvas) {
				// å¤©ç‹æ˜Ÿã®é’ç·‘è‰²
				const gradient = ctx.createRadialGradient(256, 128, 0, 256, 128, 200);
				gradient.addColorStop(0, "#40e0d0");
				gradient.addColorStop(0.5, "#20b2aa");
				gradient.addColorStop(1, "#008b8b");

				ctx.fillStyle = gradient;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// ãƒ¡ã‚¿ãƒ³ã®é›²
				for (let i = 0; i < 15; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;

					ctx.fillStyle = `rgba(64, 224, 208, ${Math.random() * 0.3 + 0.1})`;
					ctx.beginPath();
					ctx.arc(x, y, Math.random() * 20 + 5, 0, Math.PI * 2);
					ctx.fill();
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createNeptuneTexture(ctx, canvas) {
				// æµ·ç‹æ˜Ÿã®æ·±ã„é’
				const gradient = ctx.createRadialGradient(256, 128, 0, 256, 128, 200);
				gradient.addColorStop(0, "#4169e1");
				gradient.addColorStop(0.5, "#0066cc");
				gradient.addColorStop(1, "#003366");

				ctx.fillStyle = gradient;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// å¤§æš—æ–‘
				const darkSpotX = canvas.width * 0.3;
				const darkSpotY = canvas.height * 0.6;
				ctx.fillStyle = "rgba(0, 0, 100, 0.5)";
				ctx.beginPath();
				ctx.ellipse(darkSpotX, darkSpotY, 40, 25, 0, 0, Math.PI * 2);
				ctx.fill();

				// é¢¨ã®ç­‹
				for (let i = 0; i < 12; i++) {
					const y = (canvas.height / 12) * i;
					ctx.strokeStyle = `rgba(100, 149, 237, ${Math.random() * 0.3 + 0.1})`;
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(0, y);
					ctx.lineTo(canvas.width, y + Math.sin(i) * 10);
					ctx.stroke();
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createVenusTexture(ctx, canvas) {
				// é‡‘æ˜Ÿã®ç¡«é…¸é›²
				const gradient = ctx.createLinearGradient(
					0,
					0,
					canvas.width,
					canvas.height
				);
				gradient.addColorStop(0, "#ffc649");
				gradient.addColorStop(0.3, "#ffb347");
				gradient.addColorStop(0.6, "#daa520");
				gradient.addColorStop(1, "#b8860b");

				ctx.fillStyle = gradient;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// é›²ã®æ¸¦å·»ãæ¨¡æ§˜
				for (let i = 0; i < 20; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;

					ctx.fillStyle = `rgba(255, 198, 73, ${Math.random() * 0.4 + 0.2})`;
					ctx.beginPath();
					ctx.arc(x, y, Math.random() * 15 + 5, 0, Math.PI * 2);
					ctx.fill();
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createMercuryTexture(ctx, canvas) {
				// æ°´æ˜Ÿã®å²©çŸ³è¡¨é¢
				const gradient = ctx.createRadialGradient(256, 128, 0, 256, 128, 200);
				gradient.addColorStop(0, "#a0a0a0");
				gradient.addColorStop(0.5, "#8c7853");
				gradient.addColorStop(1, "#696969");

				ctx.fillStyle = gradient;
				ctx.fillRect(0, 0, canvas.width, canvas.height);

				// ã‚¯ãƒ¬ãƒ¼ã‚¿ãƒ¼ï¼ˆæœˆã‚ˆã‚Šå°ã•ãå¤šã„ï¼‰
				for (let i = 0; i < 60; i++) {
					const x = Math.random() * canvas.width;
					const y = Math.random() * canvas.height;
					const radius = Math.random() * 15 + 2;

					ctx.fillStyle = `rgba(105, 105, 105, ${Math.random() * 0.4 + 0.3})`;
					ctx.beginPath();
					ctx.arc(x, y, radius, 0, Math.PI * 2);
					ctx.fill();
				}

				return new THREE.CanvasTexture(canvas);
			}

			function createDefaultTexture(ctx, canvas, color) {
				ctx.fillStyle = `#${color.toString(16).padStart(6, "0")}`;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				return new THREE.CanvasTexture(canvas);
			}
			const celestialBodies = [
				{
					name: "å¤ªé™½",
					type: "æ’æ˜Ÿ",
					radius: 10,
					distance: 0,
					color: 0xffff00,
					imageUrl:
						"https://images.unsplash.com/photo-1614642264762-908ec80756da?w=400",
					description:
						"å¤ªé™½ç³»ã®ä¸­å¿ƒã«ã‚ã‚‹æ’æ˜Ÿã§ã€åœ°çƒã«å…‰ã¨ç†±ã‚’æä¾›ã—ã¦ã„ã‚‹å·¨å¤§ãªæ ¸èåˆç‚‰ã§ã™ã€‚",
					facts: [
						"è¡¨é¢æ¸©åº¦: ç´„5,778K (5,505Â°C)",
						"è³ªé‡: åœ°çƒã®ç´„333,000å€",
						"ç›´å¾„: åœ°çƒã®ç´„109å€",
						"å¹´é½¢: ç´„46å„„å¹´",
						"çµ„æˆ: æ°´ç´ 73%ã€ãƒ˜ãƒªã‚¦ãƒ 25%",
					],
				},
				{
					name: "æ°´æ˜Ÿ",
					type: "æƒ‘æ˜Ÿ",
					radius: 1.5,
					distance: 20,
					color: 0x8c7853,
					imageUrl:
						"https://images.unsplash.com/photo-1446776653964-20c1d3a81b06?w=400",
					description:
						"å¤ªé™½ã«æœ€ã‚‚è¿‘ã„æƒ‘æ˜Ÿã§ã€æ¥µç«¯ãªæ¸©åº¦å·®ãŒç‰¹å¾´çš„ãªå°ã•ãªå²©çŸ³æƒ‘æ˜Ÿã§ã™ã€‚",
					facts: [
						"å¤ªé™½ã‹ã‚‰ã®è·é›¢: ç´„5,790ä¸‡km",
						"å…¬è»¢å‘¨æœŸ: 88æ—¥",
						"è‡ªè»¢å‘¨æœŸ: 59æ—¥",
						"è¡¨é¢æ¸©åº¦: -170Â°Cã€œ430Â°C",
						"å¤§æ°—: ã»ã¼çœŸç©ºçŠ¶æ…‹",
					],
				},
				{
					name: "é‡‘æ˜Ÿ",
					type: "æƒ‘æ˜Ÿ",
					radius: 2.3,
					distance: 30,
					color: 0xffc649,
					imageUrl:
						"https://images.unsplash.com/photo-1446776558166-79d2b5a625e2?w=400",
					description:
						"åœ°çƒã®ã€ŒåŒå­æ˜Ÿã€ã¨å‘¼ã°ã‚Œã‚‹æƒ‘æ˜Ÿã§ã€æ¿ƒåšãªå¤§æ°—ã«ã‚ˆã‚‹æ¸©å®¤åŠ¹æœã§éå¸¸ã«é«˜æ¸©ã§ã™ã€‚",
					facts: [
						"å¤ªé™½ã‹ã‚‰ã®è·é›¢: ç´„1å„„800ä¸‡km",
						"å…¬è»¢å‘¨æœŸ: 225æ—¥",
						"è¡¨é¢æ¸©åº¦: ç´„460Â°C",
						"å¤§æ°—åœ§: åœ°çƒã®ç´„90å€",
						"é€†å›è»¢ã™ã‚‹å”¯ä¸€ã®æƒ‘æ˜Ÿ",
					],
				},
				{
					name: "åœ°çƒ",
					type: "æƒ‘æ˜Ÿ",
					radius: 2.5,
					distance: 42,
					color: 0x6b93d6,
					imageUrl:
						"https://images.unsplash.com/photo-1614730321146-b6fa6a46bcb4?w=400",
					description:
						"ç§ãŸã¡ã®æ•…éƒ·ã§ã‚ã‚‹ç¾ã—ã„é’ã„æƒ‘æ˜Ÿã€‚ç”Ÿå‘½ãŒå­˜åœ¨ã™ã‚‹å”¯ä¸€çŸ¥ã‚‰ã‚ŒãŸå¤©ä½“ã§ã™ã€‚",
					facts: [
						"å¤ªé™½ã‹ã‚‰ã®è·é›¢: ç´„1å„„4,960ä¸‡km",
						"å…¬è»¢å‘¨æœŸ: 365.25æ—¥",
						"è¡¨é¢ã®71%ãŒæµ·æ´‹",
						"å¤§æ°—çµ„æˆ: çª’ç´ 78%ã€é…¸ç´ 21%",
						"å”¯ä¸€ç¢ºèªã•ã‚ŒãŸç”Ÿå‘½å­˜åœ¨æƒ‘æ˜Ÿ",
					],
				},
				{
					name: "æœˆ",
					type: "è¡›æ˜Ÿ",
					radius: 0.8,
					distance: 47,
					color: 0xc0c0c0,
					imageUrl:
						"https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400",
					description:
						"åœ°çƒã®å”¯ä¸€ã®å¤©ç„¶è¡›æ˜Ÿã§ã€åœ°çƒã®æ½®æ±ã‚„è‡ªè»¢ã«å¤§ããªå½±éŸ¿ã‚’ä¸ãˆã¦ã„ã¾ã™ã€‚",
					facts: [
						"åœ°çƒã‹ã‚‰ã®è·é›¢: ç´„38ä¸‡km",
						"ç›´å¾„: åœ°çƒã®ç´„1/4",
						"å…¬è»¢å‘¨æœŸ: ç´„27.3æ—¥",
						"åŒæœŸå›è»¢ï¼ˆå¸¸ã«åŒã˜é¢ã‚’åœ°çƒã«å‘ã‘ã‚‹ï¼‰",
						"ã‚¢ãƒãƒ­è¨ˆç”»ã§äººé¡ãŒåˆ°é”",
					],
				},
				{
					name: "ç«æ˜Ÿ",
					type: "æƒ‘æ˜Ÿ",
					radius: 2.0,
					distance: 60,
					color: 0xcd5c5c,
					imageUrl:
						"https://images.unsplash.com/photo-1446776653964-20c1d3a81b06?w=400",
					description:
						"ã€Œèµ¤ã„æƒ‘æ˜Ÿã€ã¨ã—ã¦çŸ¥ã‚‰ã‚Œã€å°†æ¥ã®äººé¡ç§»ä½å€™è£œã¨ã—ã¦æ³¨ç›®ã•ã‚Œã‚‹æƒ‘æ˜Ÿã§ã™ã€‚",
					facts: [
						"å¤ªé™½ã‹ã‚‰ã®è·é›¢: ç´„2å„„2,790ä¸‡km",
						"å…¬è»¢å‘¨æœŸ: 687æ—¥",
						"1æ—¥: 24æ™‚é–“37åˆ†",
						"æ¥µå† ã«æ°·ãŒå­˜åœ¨",
						"å¤ªé™½ç³»æœ€å¤§ã®ç«å±±ã‚ªãƒªãƒ³ãƒã‚¹å±±ãŒã‚ã‚‹",
					],
				},
				{
					name: "æœ¨æ˜Ÿ",
					type: "æƒ‘æ˜Ÿ",
					radius: 6.0,
					distance: 85,
					color: 0xffa500,
					imageUrl:
						"https://images.unsplash.com/photo-1614732414444-096e5f1122d5?w=400",
					description:
						"å¤ªé™½ç³»æœ€å¤§ã®ã‚¬ã‚¹æƒ‘æ˜Ÿã§ã€å¤§èµ¤æ–‘ã¨å‘¼ã°ã‚Œã‚‹å·¨å¤§ãªåµãŒç‰¹å¾´çš„ã§ã™ã€‚",
					facts: [
						"å¤ªé™½ã‹ã‚‰ã®è·é›¢: ç´„7å„„7,830ä¸‡km",
						"è³ªé‡: åœ°çƒã®ç´„318å€",
						"è¡›æ˜Ÿæ•°: 95å€‹ä»¥ä¸Š",
						"å¤§èµ¤æ–‘: åœ°çƒ2-3å€‹åˆ†ã®å¤§ãã•ã®åµ",
						"ä¸»æˆåˆ†: æ°´ç´ ã¨ãƒ˜ãƒªã‚¦ãƒ ",
					],
				},
				{
					name: "åœŸæ˜Ÿ",
					type: "æƒ‘æ˜Ÿ",
					radius: 5.2,
					distance: 110,
					color: 0xffb347,
					imageUrl:
						"https://images.unsplash.com/photo-1446776708417-3aabf90b64be?w=400",
					description:
						"ç¾ã—ã„ãƒªãƒ³ã‚°ã§æœ‰åãªã‚¬ã‚¹æƒ‘æ˜Ÿã§ã€å¯†åº¦ãŒæ°´ã‚ˆã‚Šä½ã„å”¯ä¸€ã®æƒ‘æ˜Ÿã§ã™ã€‚",
					facts: [
						"å¤ªé™½ã‹ã‚‰ã®è·é›¢: ç´„14å„„2,700ä¸‡km",
						"å¯†åº¦: 0.687g/cmÂ³ï¼ˆæ°´ã‚ˆã‚Šè»½ã„ï¼‰",
						"ãƒªãƒ³ã‚°: æ°·ã¨å²©çŸ³ã®ç²’å­ã§æ§‹æˆ",
						"è¡›æ˜Ÿæ•°: 146å€‹ä»¥ä¸Š",
						"æœ€å¤§ã®è¡›æ˜Ÿã‚¿ã‚¤ã‚¿ãƒ³ã¯å¤§æ°—ã‚’æŒã¤",
					],
				},
				{
					name: "å¤©ç‹æ˜Ÿ",
					type: "æƒ‘æ˜Ÿ",
					radius: 3.8,
					distance: 140,
					color: 0x40e0d0,
					imageUrl:
						"https://images.unsplash.com/photo-1446776877081-d282a0f896e2?w=400",
					description:
						"æ¨ªå€’ã—ã«å›è»¢ã™ã‚‹æ°·æƒ‘æ˜Ÿã§ã€ãƒ¡ã‚¿ãƒ³ã«ã‚ˆã‚Šç¾ã—ã„é’ç·‘è‰²ã‚’å‘ˆã—ã¦ã„ã¾ã™ã€‚",
					facts: [
						"å¤ªé™½ã‹ã‚‰ã®è·é›¢: ç´„28å„„7,500ä¸‡km",
						"è‡ªè»¢è»¸ã®å‚¾ã: 98åº¦ï¼ˆæ¨ªå€’ã—ï¼‰",
						"å…¬è»¢å‘¨æœŸ: 84å¹´",
						"ãƒªãƒ³ã‚°: æš—ãã¦ç´°ã„",
						"å¤§æ°—: æ°´ç´ ã€ãƒ˜ãƒªã‚¦ãƒ ã€ãƒ¡ã‚¿ãƒ³",
					],
				},
				{
					name: "æµ·ç‹æ˜Ÿ",
					type: "æƒ‘æ˜Ÿ",
					radius: 3.6,
					distance: 170,
					color: 0x0066cc,
					imageUrl:
						"https://images.unsplash.com/photo-1446776558166-79d2b5a625e2?w=400",
					description:
						"å¤ªé™½ç³»æœ€é ã®æƒ‘æ˜Ÿã§ã€æœ€ã‚‚å¼·ã„é¢¨ãŒå¹ãç¾ã—ã„é’ã„æ°·æƒ‘æ˜Ÿã§ã™ã€‚",
					facts: [
						"å¤ªé™½ã‹ã‚‰ã®è·é›¢: ç´„45å„„km",
						"å…¬è»¢å‘¨æœŸ: 165å¹´",
						"é¢¨é€Ÿ: æœ€é«˜2,100km/h",
						"å¤§æš—æ–‘: æœ¨æ˜Ÿã®å¤§èµ¤æ–‘ã«ä¼¼ãŸåµ",
						"ç™ºè¦‹: æ•°å­¦çš„äºˆæ¸¬ã«ã‚ˆã‚Šç™ºè¦‹",
					],
				},
			];

			// Three.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
			let scene, camera, renderer, controls;
			let celestialObjects = [];
			let raycaster, mouse;
			let selectedObject = null;
			let modalScene, modalCamera, modalRenderer;
			let twinklingStars = [];
			let starfield;
			let isTouch = false;

			// ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ 
			const modal = document.getElementById("modal");
			const modalTitle = document.getElementById("modal-title");
			const modalContent = document.getElementById("modal-content");
			const modal3DContainer = document.getElementById("modal-3d-container");
			const celestialImage = document.getElementById("celestial-image");
			const closeBtn = document.getElementsByClassName("close")[0];
			const objectLabel = document.getElementById("object-label");
			const mobilePlanetInfo = document.getElementById("mobile-planet-info");

			init();
			animate();

			function init() {
				// ã‚·ãƒ¼ãƒ³ã®ä½œæˆ
				scene = new THREE.Scene();

				// ã‚«ãƒ¡ãƒ©ã®ä½œæˆ
				camera = new THREE.PerspectiveCamera(
					75,
					window.innerWidth / window.innerHeight,
					0.1,
					1000
				);
				camera.position.set(0, 30, 100);

				// ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ä½œæˆ
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setClearColor(0x000011);
				document.getElementById("container").appendChild(renderer.domElement);

				// ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ã‚¿ãƒ¼ã¨ãƒã‚¦ã‚¹ã®åˆæœŸåŒ–
				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				// æ˜Ÿç©ºã®èƒŒæ™¯ã‚’ä½œæˆ
				createStarfield();

				// å¤©ä½“ã‚’ä½œæˆ
				createCelestialBodies();

				// OrbitControls ï¼ˆç°¡æ˜“å®Ÿè£…ï¼‰
				setupControls();

				// ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
				setupEventListeners();

				// ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’éè¡¨ç¤º
				setTimeout(() => {
					document.getElementById("loading").style.display = "none";
				}, 2000);
			}

			function createStarfield() {
				twinklingStars = []; // é…åˆ—ã‚’åˆæœŸåŒ–

				// åŸºæœ¬ã®æ˜Ÿç©ºï¼ˆé™çš„ï¼‰
				const starsGeometry = new THREE.BufferGeometry();
				const starsMaterial = new THREE.PointsMaterial({
					color: 0xffffff,
					size: 2,
					sizeAttenuation: false,
					transparent: true,
					opacity: 0.6,
				});

				const starsVertices = [];
				for (let i = 0; i < 8000; i++) {
					const x = (Math.random() - 0.5) * 3000;
					const y = (Math.random() - 0.5) * 3000;
					const z = (Math.random() - 0.5) * 3000;
					starsVertices.push(x, y, z);
				}

				starsGeometry.setAttribute(
					"position",
					new THREE.Float32BufferAttribute(starsVertices, 3)
				);
				starfield = new THREE.Points(starsGeometry, starsMaterial);
				scene.add(starfield);

				// å‹•çš„ãªã‚­ãƒ©ã‚­ãƒ©æ˜Ÿ
				createTwinklingStars();
			}

			function createTwinklingStars() {
				const colors = [
					0xffffff, // ç™½
					0x88ddff, // é’
					0xffaa44, // ã‚ªãƒ¬ãƒ³ã‚¸
					0xff6666, // èµ¤
					0x66ff88, // ç·‘
					0xdd88ff, // ç´«
					0xffff88, // é»„è‰²
					0x88ffff, // ã‚·ã‚¢ãƒ³
				];

				for (let i = 0; i < 800; i++) {
					const geometry = new THREE.SphereGeometry(0.15, 8, 8);
					const color = colors[Math.floor(Math.random() * colors.length)];
					const material = new THREE.MeshBasicMaterial({
						color: color,
						transparent: true,
						opacity: 0.8,
					});

					const star = new THREE.Mesh(geometry, material);
					star.position.set(
						(Math.random() - 0.5) * 2500,
						(Math.random() - 0.5) * 2500,
						(Math.random() - 0.5) * 2500
					);

					// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
					star.userData = {
						baseColor: color,
						twinkleSpeed: Math.random() * 3 + 1,
						twinkleOffset: Math.random() * Math.PI * 2,
						intensityVariation: Math.random() * 0.7 + 0.3,
						pulseSpeed: Math.random() * 2 + 0.5,
					};

					scene.add(star);
					twinklingStars.push(star);
				}
			}

			function createCelestialBodies() {
				// è»Œé“ç·šã‚’æç”»
				createOrbitLines();

				celestialBodies.forEach((bodyData) => {
					const geometry = new THREE.SphereGeometry(bodyData.radius, 32, 32);

					// ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆ
					const texture = createProceduralTexture(bodyData);
					const material = new THREE.MeshBasicMaterial({
						map: texture,
						transparent: false,
					});

					const celestialBody = new THREE.Mesh(geometry, material);

					// ä½ç½®ã‚’è¨­å®šï¼ˆå¤ªé™½ä»¥å¤–ã¯è»Œé“ä¸Šã«é…ç½®ï¼‰
					if (bodyData.name === "å¤ªé™½") {
						celestialBody.position.set(0, 0, 0);
						// å¤ªé™½ã®ç™ºå…‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
						const glowGeometry = new THREE.SphereGeometry(
							bodyData.radius * 1.5,
							32,
							32
						);
						const glowMaterial = new THREE.MeshBasicMaterial({
							color: 0xffff00,
							transparent: true,
							opacity: 0.3,
						});
						const glow = new THREE.Mesh(glowGeometry, glowMaterial);
						celestialBody.add(glow);

						// å¤ªé™½å…‰ç·šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
						createSunRays(celestialBody);
					} else if (bodyData.name === "æœˆ") {
						// åœ°çƒã®å‘¨ã‚Šã«é…ç½®
						const earthPosition = celestialObjects.find(
							(obj) => obj.userData.name === "åœ°çƒ"
						)?.position || { x: 42, y: 0, z: 0 };
						celestialBody.position.set(
							earthPosition.x + 5,
							earthPosition.y,
							earthPosition.z
						);
					} else {
						const angle = Math.random() * Math.PI * 2;
						celestialBody.position.set(
							Math.cos(angle) * bodyData.distance,
							(Math.random() - 0.5) * 5,
							Math.sin(angle) * bodyData.distance
						);
					}

					celestialBody.userData = bodyData;
					celestialObjects.push(celestialBody);
					scene.add(celestialBody);
				});

				// åœŸæ˜Ÿã®ãƒªãƒ³ã‚°ã‚’è¿½åŠ 
				const saturnRing = createSaturnRing();
				const saturn = celestialObjects.find(
					(obj) => obj.userData.name === "åœŸæ˜Ÿ"
				);
				if (saturn) {
					saturn.add(saturnRing);
				}
			}

			function createOrbitLines() {
				celestialBodies.forEach((bodyData) => {
					if (bodyData.distance > 0 && bodyData.name !== "æœˆ") {
						const orbitGeometry = new THREE.RingGeometry(
							bodyData.distance - 0.3,
							bodyData.distance + 0.3,
							64
						);
						const orbitMaterial = new THREE.MeshBasicMaterial({
							color: 0x888888,
							transparent: true,
							opacity: 0.7,
							side: THREE.DoubleSide,
						});
						const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
						orbit.rotation.x = Math.PI / 2;
						scene.add(orbit);
					}
				});
			}

			function createSunRays(sunObject) {
				for (let i = 0; i < 8; i++) {
					const rayGeometry = new THREE.CylinderGeometry(0.1, 0.1, 50, 8);
					const rayMaterial = new THREE.MeshBasicMaterial({
						color: 0xffff00,
						transparent: true,
						opacity: 0.1,
					});
					const ray = new THREE.Mesh(rayGeometry, rayMaterial);

					const angle = (i / 8) * Math.PI * 2;
					ray.position.set(Math.cos(angle) * 15, 0, Math.sin(angle) * 15);
					ray.rotation.z = angle + Math.PI / 2;

					sunObject.add(ray);
				}
			}

			function createSaturnRing() {
				const ringGeometry = new THREE.RingGeometry(7, 12, 32);
				const ringMaterial = new THREE.MeshBasicMaterial({
					color: 0xcccccc,
					transparent: true,
					opacity: 0.6,
					side: THREE.DoubleSide,
				});
				const ring = new THREE.Mesh(ringGeometry, ringMaterial);
				ring.rotation.x = Math.PI / 2;
				return ring;
			}

			function setupControls() {
				let isDragging = false;
				let previousMousePosition = { x: 0, y: 0 };
				let touches = [];
				let lastTouchDistance = 0;
				let lastTouchCenter = { x: 0, y: 0 };

				// ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
				renderer.domElement.addEventListener("mousedown", (e) => {
					if (!isTouch) {
						isDragging = true;
						previousMousePosition = { x: e.clientX, y: e.clientY };
					}
				});

				renderer.domElement.addEventListener("mousemove", (e) => {
					if (isDragging && !isTouch) {
						const deltaMove = {
							x: e.clientX - previousMousePosition.x,
							y: e.clientY - previousMousePosition.y,
						};

						rotateCamera(deltaMove.x * 0.005, deltaMove.y * 0.005);
						previousMousePosition = { x: e.clientX, y: e.clientY };
					}

					// ãƒ›ãƒãƒ¼åŠ¹æœ
					if (!isTouch) {
						updateMousePosition(e);
						checkHover();
					}
				});

				renderer.domElement.addEventListener("mouseup", () => {
					isDragging = false;
				});

				renderer.domElement.addEventListener("wheel", (e) => {
					if (!isTouch) {
						e.preventDefault();
						const zoomSpeed = 0.1;
						zoomCamera(e.deltaY * zoomSpeed * 0.001);
					}
				});

				// ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆï¼ˆæ“ä½œç”¨ï¼‰
				renderer.domElement.addEventListener(
					"touchstart",
					(e) => {
						onTouchStart(e);

						touches = Array.from(e.touches);

						if (touches.length === 1) {
							// å˜ä¸€ã‚¿ãƒƒãƒ - å›è»¢
							isDragging = true;
							previousMousePosition = {
								x: touches[0].clientX,
								y: touches[0].clientY,
							};
						} else if (touches.length === 2) {
							// ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ - ã‚ºãƒ¼ãƒ ã¨ãƒ‘ãƒ³
							isDragging = false;
							lastTouchDistance = getTouchDistance(touches[0], touches[1]);
							lastTouchCenter = getTouchCenter(touches[0], touches[1]);
						}
					},
					{ passive: false }
				);

				renderer.domElement.addEventListener(
					"touchmove",
					(e) => {
						e.preventDefault();
						touches = Array.from(e.touches);

						if (touches.length === 1 && isDragging) {
							// å˜ä¸€ã‚¿ãƒƒãƒ - å›è»¢
							const deltaMove = {
								x: touches[0].clientX - previousMousePosition.x,
								y: touches[0].clientY - previousMousePosition.y,
							};

							rotateCamera(deltaMove.x * 0.008, deltaMove.y * 0.008);
							previousMousePosition = {
								x: touches[0].clientX,
								y: touches[0].clientY,
							};
						} else if (touches.length === 2) {
							// ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ - ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ  & ãƒ‘ãƒ³
							const currentDistance = getTouchDistance(touches[0], touches[1]);
							const currentCenter = getTouchCenter(touches[0], touches[1]);

							// ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ 
							const zoomDelta = (lastTouchDistance - currentDistance) * 0.01;
							zoomCamera(zoomDelta);

							// ãƒ‘ãƒ³
							const panDelta = {
								x: (currentCenter.x - lastTouchCenter.x) * 0.1,
								y: (currentCenter.y - lastTouchCenter.y) * 0.1,
							};
							panCamera(panDelta.x, panDelta.y);

							lastTouchDistance = currentDistance;
							lastTouchCenter = currentCenter;
						}
					},
					{ passive: false }
				);

				renderer.domElement.addEventListener(
					"touchend",
					(e) => {
						onTouchEnd(e);

						touches = Array.from(e.touches);

						if (touches.length === 0) {
							isDragging = false;
						} else if (touches.length === 1) {
							// 2æœ¬æŒ‡ã‹ã‚‰1æœ¬æŒ‡ã«ãªã£ãŸå ´åˆ
							isDragging = true;
							previousMousePosition = {
								x: touches[0].clientX,
								y: touches[0].clientY,
							};
						}
					},
					{ passive: false }
				);

				function getTouchDistance(touch1, touch2) {
					const dx = touch1.clientX - touch2.clientX;
					const dy = touch1.clientY - touch2.clientY;
					return Math.sqrt(dx * dx + dy * dy);
				}

				function getTouchCenter(touch1, touch2) {
					return {
						x: (touch1.clientX + touch2.clientX) / 2,
						y: (touch1.clientY + touch2.clientY) / 2,
					};
				}

				function rotateCamera(deltaX, deltaY) {
					const spherical = new THREE.Spherical();
					spherical.setFromVector3(camera.position);

					spherical.theta -= deltaX;
					spherical.phi = Math.max(
						0.1,
						Math.min(Math.PI - 0.1, spherical.phi - deltaY)
					);

					camera.position.setFromSpherical(spherical);
					camera.lookAt(scene.position);
				}

				function zoomCamera(delta) {
					const zoomFactor = 1 + delta;
					camera.position.multiplyScalar(zoomFactor);

					// ã‚ºãƒ¼ãƒ åˆ¶é™
					const distance = camera.position.length();
					if (distance < 20) {
						camera.position.normalize().multiplyScalar(20);
					} else if (distance > 500) {
						camera.position.normalize().multiplyScalar(500);
					}
				}

				function panCamera(deltaX, deltaY) {
					const vector = new THREE.Vector3();
					vector.setFromMatrixColumn(camera.matrix, 0); // ã‚«ãƒ¡ãƒ©ã®å³æ–¹å‘
					vector.multiplyScalar(-deltaX);
					camera.position.add(vector);

					vector.setFromMatrixColumn(camera.matrix, 1); // ã‚«ãƒ¡ãƒ©ã®ä¸Šæ–¹å‘
					vector.multiplyScalar(deltaY);
					camera.position.add(vector);
				}
			}

			function updateMousePosition(event) {
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			}

			function checkHover() {
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects(
					celestialObjects.filter(
						(obj) => obj.userData.name && obj.userData.distance !== undefined
					)
				);

				if (intersects.length > 0) {
					const object = intersects[0].object;
					if (object.userData.name) {
						showObjectLabel(object.userData.name, event.clientX, event.clientY);
						document.body.style.cursor = "pointer";
					}
				} else {
					hideObjectLabel();
					document.body.style.cursor = "crosshair";
				}
			}

			function showObjectLabel(name, x, y) {
				objectLabel.textContent = name;
				objectLabel.style.left = x + 10 + "px";
				objectLabel.style.top = y - 30 + "px";
				objectLabel.style.display = "block";
			}

			function hideObjectLabel() {
				objectLabel.style.display = "none";
			}

			function setupEventListeners() {
				// ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ç”¨ï¼‰
				renderer.domElement.addEventListener("click", (e) => {
					if (!isTouch) {
						onObjectClick(e);
					}
				});

				// ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆ
				closeBtn.onclick = () => {
					modal.style.display = "none";
					hideMobilePlanetInfo();
				};
				window.onclick = (event) => {
					if (event.target === modal) {
						modal.style.display = "none";
						hideMobilePlanetInfo();
					}
				};

				// ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆ
				window.addEventListener("resize", onWindowResize);
			}

			let touchStartTime = 0;
			let touchObject = null;

			function onTouchStart(event) {
				event.preventDefault();
				isTouch = true;
				touchStartTime = Date.now();

				if (event.touches.length === 1) {
					const touch = event.touches[0];
					updateMousePositionFromTouch(touch);
					raycaster.setFromCamera(mouse, camera);

					const intersects = raycaster.intersectObjects(
						celestialObjects.filter(
							(obj) => obj.userData.name && obj.userData.distance !== undefined
						)
					);

					if (intersects.length > 0) {
						touchObject = intersects[0].object;
						showMobilePlanetInfo(
							touchObject.userData.name,
							touch.clientX,
							touch.clientY
						);
					}
				}
			}

			function onTouchEnd(event) {
				event.preventDefault();
				const touchEndTime = Date.now();
				const touchDuration = touchEndTime - touchStartTime;

				if (touchDuration < 300 && touchObject && event.touches.length === 0) {
					// çŸ­ã„ã‚¿ãƒƒãƒ—ã§ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤º
					showModal(touchObject.userData);
				}

				if (event.touches.length === 0) {
					setTimeout(() => {
						hideMobilePlanetInfo();
					}, 1500);
					touchObject = null;
					isTouch = false;
				}
			}

			function updateMousePositionFromTouch(touch) {
				mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
			}

			function showMobilePlanetInfo(name, x, y) {
				if (window.innerWidth <= 768) {
					mobilePlanetInfo.textContent = name;
					mobilePlanetInfo.style.display = "block";

					// ç”»é¢å¤–ã«å‡ºãªã„ã‚ˆã†ã«èª¿æ•´
					let left = x - 50;
					let top = y - 60;

					if (left < 10) left = 10;
					if (left > window.innerWidth - 120) left = window.innerWidth - 120;
					if (top < 10) top = 10;
					if (top > window.innerHeight - 80) top = window.innerHeight - 80;

					mobilePlanetInfo.style.left = left + "px";
					mobilePlanetInfo.style.top = top + "px";
					mobilePlanetInfo.style.transform = "none";
				}
			}

			function hideMobilePlanetInfo() {
				mobilePlanetInfo.style.display = "none";
			}

			function onObjectClick(event) {
				updateMousePosition(event);
				raycaster.setFromCamera(mouse, camera);

				const intersects = raycaster.intersectObjects(
					celestialObjects.filter(
						(obj) => obj.userData.name && obj.userData.distance !== undefined
					)
				);

				if (intersects.length > 0) {
					const selectedObj = intersects[0].object;
					showModal(selectedObj.userData);
				}
			}

			function showModal(bodyData) {
				modalTitle.textContent = `${bodyData.name} (${bodyData.type})`;

				let content = `
                <p>${bodyData.description}</p>
                <h3>åŸºæœ¬ãƒ‡ãƒ¼ã‚¿</h3>
                <ul class="fact-list">
            `;

				bodyData.facts.forEach((fact) => {
					content += `<li>${fact}</li>`;
				});

				content += "</ul>";
				modalContent.innerHTML = content;

				// 3Dãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ
				create3DModal(bodyData);

				modal.style.display = "block";
			}

			function create3DModal(bodyData) {
				// æ—¢å­˜ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã‚¯ãƒªã‚¢
				while (modal3DContainer.firstChild) {
					modal3DContainer.removeChild(modal3DContainer.firstChild);
				}

				// ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆã—ã¦ç”»åƒã¨ã—ã¦è¡¨ç¤º
				const texture = createProceduralTexture(bodyData);

				// Three.jsã®CanvasTextureã‹ã‚‰imageã‚’ä½œæˆ
				if (texture && texture.image) {
					celestialImage.src = texture.image.toDataURL();
					celestialImage.alt = `${bodyData.name}ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£`;
					celestialImage.style.display = "block";
					celestialImage.onload = function () {
						console.log(`${bodyData.name}ã®ç”»åƒèª­ã¿è¾¼ã¿å®Œäº†`);
					};
					celestialImage.onerror = function () {
						console.log(`${bodyData.name}ã®ç”»åƒèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼`);
						// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šã‚«ãƒ©ãƒ¼ã§å¡—ã‚Šã¤ã¶ã—
						const fallbackCanvas = document.createElement("canvas");
						const fallbackCtx = fallbackCanvas.getContext("2d");
						fallbackCanvas.width = 512;
						fallbackCanvas.height = 256;

						const colorHex = `#${bodyData.color.toString(16).padStart(6, "0")}`;
						fallbackCtx.fillStyle = colorHex;
						fallbackCtx.fillRect(0, 0, 512, 256);

						// å¤©ä½“åã‚’æç”»
						fallbackCtx.fillStyle = "#ffffff";
						fallbackCtx.font = "24px Arial";
						fallbackCtx.textAlign = "center";
						fallbackCtx.fillText(bodyData.name, 256, 128);

						this.src = fallbackCanvas.toDataURL();
					};
				} else {
					// ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”»åƒã‚’ç›´æ¥ä½œæˆ
					const fallbackCanvas = document.createElement("canvas");
					const fallbackCtx = fallbackCanvas.getContext("2d");
					fallbackCanvas.width = 512;
					fallbackCanvas.height = 256;

					const colorHex = `#${bodyData.color.toString(16).padStart(6, "0")}`;
					fallbackCtx.fillStyle = colorHex;
					fallbackCtx.fillRect(0, 0, 512, 256);

					// å¤©ä½“åã‚’æç”»
					fallbackCtx.fillStyle = "#ffffff";
					fallbackCtx.font = "32px Arial";
					fallbackCtx.textAlign = "center";
					fallbackCtx.fillText(bodyData.name, 256, 128);

					celestialImage.src = fallbackCanvas.toDataURL();
					celestialImage.style.display = "block";
				}

				// ãƒ¡ã‚¤ãƒ³ç”»é¢ã¨åŒã˜3Dãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆï¼ˆä¸‹éƒ¨ï¼‰
				modalScene = new THREE.Scene();
				modalCamera = new THREE.PerspectiveCamera(75, 250 / 120, 0.1, 1000);
				modalRenderer = new THREE.WebGLRenderer({
					antialias: true,
					alpha: true,
				});
				modalRenderer.setSize(250, 120);
				modalRenderer.setClearColor(0x000011, 1);
				modal3DContainer.appendChild(modalRenderer.domElement);

				// å¤©ä½“ã®3Dãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆï¼ˆãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ä½¿ç”¨ï¼‰
				const geometry = new THREE.SphereGeometry(1.5, 32, 32);
				const material = new THREE.MeshBasicMaterial({
					map: createProceduralTexture(bodyData),
					transparent: false,
				});

				const modalPlanet = new THREE.Mesh(geometry, material);
				modalScene.add(modalPlanet);

				// å¤ªé™½ã®ç‰¹åˆ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
				if (bodyData.name === "å¤ªé™½") {
					// ç™ºå…‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
					const glowGeometry = new THREE.SphereGeometry(1.8, 32, 32);
					const glowMaterial = new THREE.MeshBasicMaterial({
						color: 0xffff00,
						transparent: true,
						opacity: 0.3,
					});
					const glow = new THREE.Mesh(glowGeometry, glowMaterial);
					modalScene.add(glow);

					// å¤ªé™½å…‰ç·šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
					for (let i = 0; i < 8; i++) {
						const rayGeometry = new THREE.CylinderGeometry(0.02, 0.02, 15, 8);
						const rayMaterial = new THREE.MeshBasicMaterial({
							color: 0xffff00,
							transparent: true,
							opacity: 0.1,
						});
						const ray = new THREE.Mesh(rayGeometry, rayMaterial);

						const angle = (i / 8) * Math.PI * 2;
						ray.position.set(Math.cos(angle) * 5, 0, Math.sin(angle) * 5);
						ray.rotation.z = angle + Math.PI / 2;

						modalScene.add(ray);
					}
				}

				// åœŸæ˜Ÿã®ãƒªãƒ³ã‚°
				if (bodyData.name === "åœŸæ˜Ÿ") {
					const ringGeometry = new THREE.RingGeometry(2.2, 3.2, 32);
					const ringMaterial = new THREE.MeshBasicMaterial({
						color: 0xcccccc,
						transparent: true,
						opacity: 0.6,
						side: THREE.DoubleSide,
					});
					const ring = new THREE.Mesh(ringGeometry, ringMaterial);
					ring.rotation.x = Math.PI / 2;
					modalPlanet.add(ring);
				}

				// èƒŒæ™¯ã«æ˜Ÿã‚’è¿½åŠ 
				addModalStarfield();

				// ã‚«ãƒ¡ãƒ©ã®ä½ç½®è¨­å®š
				modalCamera.position.set(0, 0.5, 3.5);
				modalCamera.lookAt(modalScene.position);

				// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
				let modalAnimationId;
				function animateModal() {
					if (modal.style.display === "block") {
						modalAnimationId = requestAnimationFrame(animateModal);

						const time = Date.now() * 0.001;

						// å¤©ä½“ã®å›è»¢
						if (bodyData.name === "å¤ªé™½") {
							modalPlanet.rotation.y += 0.005;
							// å¤ªé™½å…‰ç·šã®å›è»¢
							modalScene.children.forEach((child) => {
								if (
									child.geometry &&
									child.geometry.type === "CylinderGeometry"
								) {
									child.rotation.z += 0.01;
								}
							});
						} else {
							modalPlanet.rotation.y += 0.01;
						}

						// ã‚«ãƒ¡ãƒ©ã®å¾®å¦™ãªå‹•ã
						modalCamera.position.x = Math.sin(time * 0.5) * 0.3;
						modalCamera.position.y = 0.5 + Math.cos(time * 0.3) * 0.1;
						modalCamera.lookAt(modalScene.position);

						modalRenderer.render(modalScene, modalCamera);
					} else {
						cancelAnimationFrame(modalAnimationId);
					}
				}
				animateModal();
			}

			function addModalStarfield() {
				// ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã®å°ã•ãªæ˜Ÿç©ºã‚’ä½œæˆ
				const starsGeometry = new THREE.BufferGeometry();
				const starsMaterial = new THREE.PointsMaterial({
					color: 0xffffff,
					size: 1,
					sizeAttenuation: false,
					transparent: true,
					opacity: 0.6,
				});

				const starsVertices = [];
				for (let i = 0; i < 200; i++) {
					const x = (Math.random() - 0.5) * 50;
					const y = (Math.random() - 0.5) * 50;
					const z = (Math.random() - 0.5) * 50;
					starsVertices.push(x, y, z);
				}

				starsGeometry.setAttribute(
					"position",
					new THREE.Float32BufferAttribute(starsVertices, 3)
				);
				const stars = new THREE.Points(starsGeometry, starsMaterial);
				modalScene.add(stars);

				// ã‚­ãƒ©ã‚­ãƒ©æ˜Ÿã‚‚è¿½åŠ 
				const colors = [0xffffff, 0x88ddff, 0xffaa44, 0xff6666, 0x66ff88];
				for (let i = 0; i < 20; i++) {
					const geometry = new THREE.SphereGeometry(0.05, 8, 8);
					const color = colors[Math.floor(Math.random() * colors.length)];
					const material = new THREE.MeshBasicMaterial({
						color: color,
						transparent: true,
						opacity: 0.6,
					});

					const star = new THREE.Mesh(geometry, material);
					star.position.set(
						(Math.random() - 0.5) * 40,
						(Math.random() - 0.5) * 40,
						(Math.random() - 0.5) * 40
					);

					modalScene.add(star);
				}
			}

			function create3DModelFallback(bodyData) {
				// ãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨ã®3Dã‚·ãƒ¼ãƒ³ã‚’ä½œæˆ
				modalScene = new THREE.Scene();
				modalCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
				modalRenderer = new THREE.WebGLRenderer({
					antialias: true,
					alpha: true,
				});
				modalRenderer.setSize(250, 250);
				modalRenderer.setClearColor(0x000011, 1);
				modal3DContainer.appendChild(modalRenderer.domElement);

				// å¤©ä½“ã®3Dãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ
				const geometry = new THREE.SphereGeometry(2, 32, 32);
				let material;

				if (bodyData.name === "å¤ªé™½") {
					material = new THREE.MeshBasicMaterial({
						color: bodyData.color,
						transparent: true,
					});

					// å¤ªé™½ã®ç™ºå…‰ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
					const glowGeometry = new THREE.SphereGeometry(2.5, 32, 32);
					const glowMaterial = new THREE.MeshBasicMaterial({
						color: 0xffff00,
						transparent: true,
						opacity: 0.3,
					});
					const glow = new THREE.Mesh(glowGeometry, glowMaterial);
					modalScene.add(glow);
				} else {
					material = new THREE.MeshBasicMaterial({
						color: bodyData.color,
						transparent: true,
					});
				}

				const modalPlanet = new THREE.Mesh(geometry, material);
				modalScene.add(modalPlanet);

				// åœŸæ˜Ÿã®å ´åˆã¯ãƒªãƒ³ã‚°ã‚’è¿½åŠ 
				if (bodyData.name === "åœŸæ˜Ÿ") {
					const ringGeometry = new THREE.RingGeometry(3, 4.5, 32);
					const ringMaterial = new THREE.MeshBasicMaterial({
						color: 0xcccccc,
						transparent: true,
						opacity: 0.6,
						side: THREE.DoubleSide,
					});
					const ring = new THREE.Mesh(ringGeometry, ringMaterial);
					ring.rotation.x = Math.PI / 2;
					modalPlanet.add(ring);
				}

				// ã‚«ãƒ¡ãƒ©ã®ä½ç½®è¨­å®š
				modalCamera.position.set(0, 1, 5);
				modalCamera.lookAt(modalScene.position);

				// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
				function animateModal() {
					if (modal.style.display === "block") {
						requestAnimationFrame(animateModal);
						modalPlanet.rotation.y += 0.02;
						modalRenderer.render(modalScene, modalCamera);
					}
				}
				animateModal();
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);

				const time = Date.now() * 0.001;

				// å‹•çš„ãªæ˜Ÿã®ã‚­ãƒ©ã‚­ãƒ©ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
				twinklingStars.forEach((star) => {
					const userData = star.userData;

					// ãƒ©ãƒ³ãƒ€ãƒ ãªå¼·åº¦å¤‰åŒ–
					const twinkle =
						Math.sin(time * userData.twinkleSpeed + userData.twinkleOffset) *
							userData.intensityVariation +
						0.5;
					const pulse =
						Math.sin(time * userData.pulseSpeed + userData.twinkleOffset * 2) *
							0.3 +
						0.7;

					// å…‰é‡ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«å¤‰åŒ–
					star.material.opacity = twinkle * pulse;

					// è‰²ã®è¼åº¦ã‚‚ãƒ©ãƒ³ãƒ€ãƒ ã«å¤‰åŒ–
					const brightness = (twinkle + pulse) / 2;
					const color = new THREE.Color(userData.baseColor);
					color.multiplyScalar(brightness + 0.3);
					star.material.color = color;

					// ã‚µã‚¤ã‚ºã‚‚å¾®å¦™ã«å¤‰åŒ–
					const sizeVariation = 1 + (twinkle - 0.5) * 0.3;
					star.scale.setScalar(sizeVariation);
				});

				// å¤©ä½“ã®å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
				celestialObjects.forEach((obj) => {
					if (obj.userData.name === "å¤ªé™½") {
						obj.rotation.y += 0.005;
						// å¤ªé™½ã®å…‰ç·šã‚‚å›è»¢
						obj.children.forEach((child) => {
							if (
								child.geometry &&
								child.geometry.type === "CylinderGeometry"
							) {
								child.rotation.z += 0.01;
							}
						});
					} else if (obj.userData.name && obj.userData.distance !== undefined) {
						obj.rotation.y += 0.01;
						// è»Œé“é‹å‹•
						const distance = obj.userData.distance;
						if (distance > 0 && obj.userData.name !== "æœˆ") {
							obj.position.x =
								Math.cos(time * 0.1 * (1 / Math.sqrt(distance))) * distance;
							obj.position.z =
								Math.sin(time * 0.1 * (1 / Math.sqrt(distance))) * distance;
						} else if (obj.userData.name === "æœˆ") {
							// æœˆã¯åœ°çƒã®å‘¨ã‚Šã‚’å›ã‚‹
							const earth = celestialObjects.find(
								(o) => o.userData.name === "åœ°çƒ"
							);
							if (earth) {
								obj.position.x = earth.position.x + Math.cos(time * 2) * 5;
								obj.position.z = earth.position.z + Math.sin(time * 2) * 5;
							}
						}
					}
				});

				// ã‚«ãƒ¡ãƒ©ã‚’å¸¸ã«ä¸­å¿ƒã‚’å‘ã‹ã›ã‚‹
				camera.lookAt(scene.position);

				renderer.render(scene, camera);
			}
		</script>
	</body>
</html>
